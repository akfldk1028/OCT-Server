import {
  CreateMessageResult,
  LoggingLevel,
  Resource,
  Root,
  ServerNotification,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";
import React, {
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react";
import { useConnection } from "../../../lib/hooks/useConnection";
import { useDraggablePane } from "../../../lib/hooks/useDraggablePane";
import { StdErrNotification } from "../../../lib/notificationTypes";

// Import components
import ConsoleTab from "../../../common/components/ConsoleTab";
import HistoryAndNotifications from "../../../common/components/History";
import PingTab from "../../../common/components/PingTab";
import PromptsTab, { Prompt } from "../../../common/components/PromptsTab";
import ResourcesTab from "../../../common/components/ResourcesTab";
import RootsTab from "../../../common/components/RootsTab";
import SamplingTab from "../../../common/components/SamplingTab";
import Sidebar from "../../../common/components/Sidebar";
import ToolsTab from "../../../common/components/ToolsTab";
import { DEFAULT_INSPECTOR_CONFIG, CONFIG_LOCAL_STORAGE_KEY } from "../../../lib/constants";
import { getMCPProxyAddress } from "../../../utils/configUtils";

// Import refactored modules
import useLocalStorage from "../../../lib/hooks/useLocalStorage";
import { useMcpApi } from "../../../lib/hooks/useMcpApi";
import { ExtendedPendingRequest } from "../../../types";
import TabsContainer from "../../../common/components/inspector/TabsContainer";

// Multi-Server Components
import ServerManagementSidebar from "../../../features/server/components/ServerManagementSidebar";


// Server Info interface for multi-server support
interface ServerInfo {
  id: string;
  name: string;
  status: 'stopped' | 'running' | 'error' | 'starting' | 'stopping';
  type: string;
  serverType?: string;
  host?: string;
  port?: number;
  sessionId?: string;
  activeSessions?: number;
  config?: {
    command?: string;
    args?: string[];
    transportType?: 'stdio' | 'sse' | 'streamable-http';
    sseUrl?: string;
    env?: Record<string, string>;
    execution?: {
      command: string;
      args: string[];
      env?: Record<string, string>;
    };
  };
  mcpClient?: any;
  connectionStatus?: 'connected' | 'disconnected' | 'connecting' | 'error' | 'error-connecting-to-proxy';
  lastError?: string;
}

const JobPage = () => {
  const [tab, setTab] = useState("resources"); // Í∏∞Î≥∏Í∞í

  // üî• Multi-Server State
  const [servers, setServers] = useState<ServerInfo[]>([]);
  const [selectedServer, setSelectedServer] = useState<ServerInfo | null>(null);
  const [selectedServers, setSelectedServers] = useState<Set<string>>(new Set());
  const [multiServerMode, setMultiServerMode] = useState(true); // üî• Í∏∞Î≥∏Í∞íÏùÑ trueÎ°ú Î≥ÄÍ≤Ω

  // Notification for multi-server operations
  const [notification, setNotification] = useState<{
    message: string;
    type: 'success' | 'error' | 'info';
  } | null>(null);

  // Single server state (for backward compatibility)
  const [command, setCommand] = useLocalStorage("lastCommand", "mcp-server-everything");
  const [args, setArgs] = useLocalStorage("lastArgs", "");
  const [sseUrl, setSseUrl] = useLocalStorage("lastSseUrl", "http://localhost:3000/mcp/sse");
  const [transportType, setTransportType] = useLocalStorage<"stdio" | "sse" | "streamable-http">(
    "lastTransportType",
    "stdio"
  );
  const [bearerToken, setBearerToken] = useLocalStorage("lastBearerToken", "");
  const [headerName, setHeaderName] = useLocalStorage("lastHeaderName", "");

  // App-level state
  const [notifications, setNotifications] = useState<ServerNotification[]>([]);
  const [stdErrNotifications, setStdErrNotifications] = useState<StdErrNotification[]>([]);
  const [roots, setRoots] = useState<Root[]>([]);
  const [env, setEnv] = useState<Record<string, string>>({});
  const [pendingSampleRequests, setPendingSampleRequests] = useState<ExtendedPendingRequest[]>([]);
  const [selectedResource, setSelectedResource] = useState<Resource | null>(null);
  const [selectedPrompt, setSelectedPrompt] = useState<Prompt | null>(null);
  const [selectedTool, setSelectedTool] = useState<Tool | null>(null);

  // Use useLocalStorage for config with proper type handling
  const [config, setConfig] = useLocalStorage(
    CONFIG_LOCAL_STORAGE_KEY,
    DEFAULT_INSPECTOR_CONFIG
  );

  const nextRequestId = useRef(0);
  const rootsRef = useRef<Root[]>([]);
  const progressTokenRef = useRef(0);

  const { height: historyPaneHeight, handleDragStart } = useDraggablePane(300);

  // üî• Dynamic connection params based on server selection
  const connectionParams = React.useMemo(() => {
    console.log("=== Connection Params Debug ===");
    console.log("multiServerMode:", multiServerMode);
    console.log("selectedServer:", selectedServer);
    
    if (multiServerMode && selectedServer?.config?.execution) {
      const execConfig = selectedServer.config.execution;
      const serverTransportType = (selectedServer.config.transportType || "stdio") as 'stdio' | 'sse' | 'streamable-http';
      
      console.log("execConfig:", execConfig);
      console.log("serverTransportType:", serverTransportType);
      
      // Create server-specific URL
      let serverSseUrl: string;
      switch (serverTransportType) {
        case 'stdio':
          const envStr = Object.keys(execConfig.env || {}).length > 0 ? 
          encodeURIComponent(JSON.stringify(execConfig.env)) : 
          encodeURIComponent('{}');
          serverSseUrl = `http://localhost:4303/stdio?transportType=stdio&command=${encodeURIComponent(execConfig.command)}&args=${encodeURIComponent(execConfig.args ? execConfig.args.join(' ') : '')}&env=${envStr}&serverName=${selectedServer.id}`;

          // serverSseUrl = `http://localhost:4303/stdio?transportType=stdio&command=${encodeURIComponent(execConfig.command)}&args=${encodeURIComponent(execConfig.args ? execConfig.args.join(' ') : '')}&env=${envStr}`;
          break;
        case 'sse':
          serverSseUrl = `http://localhost:4303/sse?transportType=sse`;
          break;
        case 'streamable-http':
          serverSseUrl = `http://localhost:4303/mcp?transportType=streamable-http`;
          break;
        default:
          serverSseUrl = `http://localhost:4303/stdio?transportType=stdio&command=${encodeURIComponent(execConfig.command)}&args=${encodeURIComponent(execConfig.args ? execConfig.args.join(' ') : '')}`;
      }
      
      const params = {
        transportType: serverTransportType,
        command: execConfig.command,
        args: execConfig.args ? execConfig.args.join(' ') : "",
        sseUrl: serverSseUrl,
        env: execConfig.env || {},
        bearerToken,
        headerName,
        config,
        serverName: selectedServer?.id
      };
      
      console.log("Generated connection params:", params);
      console.log("================================");
      return params;
    } else {
      // Single server mode (backward compatibility)
      const params = {
        transportType,
        command,
        args,
        sseUrl,
        env,
        bearerToken,
        headerName,
        config,
        serverName: selectedServer?.id
      };
      
      console.log("Single server mode params:", params);
      console.log("================================");
      return params;
    }
  }, [multiServerMode, selectedServer, transportType, command, args, sseUrl, env, bearerToken, headerName, config]);

  // Set up the connection
  const {
    connectionStatus,
    serverCapabilities,
    mcpClient,
    requestHistory,
    makeRequest,
    sendNotification,
    handleCompletion,
    completionsSupported,
    connect: connectMcpServer,
    disconnect: disconnectMcpServer,
  } = useConnection({
    ...connectionParams,
    onNotification: (notification) => {
      setNotifications((prev) => [...prev, notification as ServerNotification]);
    },
    onStdErrNotification: (notification) => {
      setStdErrNotifications((prev) => [
        ...prev,
        notification as StdErrNotification,
      ]);
    },
    onPendingRequest: (request, resolve, reject) => {
      setPendingSampleRequests((prev) => [
        ...prev,
        { id: nextRequestId.current++, request, resolve, reject },
      ]);
    },
    getRoots: () => rootsRef.current,
  });

  // üî• Connection Status Debug
  useEffect(() => {
    console.log("=== Connection Status Debug ===");
    console.log("connectionStatus:", connectionStatus);
    console.log("mcpClient:", mcpClient ? "Connected" : "Not connected");
    console.log("serverCapabilities:", serverCapabilities);
    console.log("===============================");
  }, [connectionStatus, mcpClient, serverCapabilities]);

  // Initialize the API service
  const {
    // API error states
    errors,

    // Resources related
    resources,
    resourceTemplates,
    resourceContent,
    resourceSubscriptions,
    listResources,
    listResourceTemplates,
    readResource,
    subscribeToResource,
    unsubscribeFromResource,
    clearResources,
    clearResourceTemplates,

    // Prompts related
    prompts,
    promptContent,
    listPrompts,
    getPrompt,
    clearPrompts,

    // Tools related
    tools,
    toolResult,
    listTools,
    callTool,
    clearTools,

    // Other API methods
    ping,
    setLogLevel,
  } = useMcpApi(makeRequest, {
    resources: null,
    prompts: null,
    tools: null,
  });



  // üî• Electron API helper (only for multi-server mode)
  const ensureApi = () => {
    if (!window.api) {
      console.warn('Electron API not available. Multi-server features will be limited.');
      return null;
    }
    return window.api;
  };

  // üî• Multi-Server Management Functions
// src/renderer/features/server/pages/job-page.tsx
  const refreshServerStatus = useCallback(async () => {
    
    try {
      const api = ensureApi();
      if (!api) return;
      
      console.log("üîÑ Refreshing server status...");
      const fullConfigs = await api.getFullConfigs();
      const activeSessions = await api.getActiveSessions();
      
      // ÏÑ∏ÏÖò Ï†ïÎ≥¥ÏôÄ ÏÑúÎ≤Ñ Ï†ïÎ≥¥ Î≥ëÌï©
      const serversWithSessions = await Promise.all(
        fullConfigs.map(async (server) => {
          const mySession = activeSessions.find(
            (s: any) => s.serverName === server.name || s.serverName === server.id
          );
          
          // Ï†ÄÏû•Îêú ÏÑ∏ÏÖò Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
          const savedSession = await api.getServerSession(server.id);
          
          return {
            ...server,
            sessionId: mySession?.sessionId || savedSession?.sessionId || null,
            activeSessions: mySession?.sessionCount || 0,
            connectionStatus: server.status === 'running' && mySession ? 'connected' : 'disconnected',
          };
        })
      );
      
      setServers(serversWithSessions);
      
      if (selectedServer) {
        const updatedServer = serversWithSessions.find(server => server.id === selectedServer.id);
        if (updatedServer) {
          setSelectedServer(updatedServer);
        }
      }
    } catch (error) {
      console.error('Error refreshing server status:', error);
    }
  }, [multiServerMode, selectedServer?.id]);


const connectWithSessionReuse = useCallback(async () => {
  if (!selectedServer) return;
  if (connectionStatus === "connected" && mcpClient) {
    console.log("Ïù¥ÎØ∏ Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.");
    return;
  }
  try {
    const api = ensureApi();
    if (!api) return;

    // 1. ÌôúÏÑ± ÏÑ∏ÏÖò Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
    const activeSessions = await api.getActiveSessions(selectedServer.id);
    const mySession = activeSessions.find(
      (s: any) => s.serverName === selectedServer.id || s.serverName === selectedServer.name
    );

    if (mySession && mySession.sessionId) {
      // ‚úÖ Í∏∞Ï°¥ ÏÑ∏ÏÖòÏù¥ ÏûàÏúºÎ©¥ ÏïÑÎ¨¥Í≤ÉÎèÑ ÌïòÏßÄ ÏïäÏùå!
      console.log("üîÑ ‚úÖ‚úÖ‚úÖ‚úÖÍ∏∞Ï°¥ ÏÑ∏ÏÖòÏù¥ ÏûàÏùå:", mySession.sessionId);
      await connectMcpServer();
      return;
    } else {
      // ‚ùå Í∏∞Ï°¥ ÏÑ∏ÏÖòÏù¥ ÏóÜÏùÑ ÎïåÎßå ÏÉàÎ°ú Ïó∞Í≤∞
      console.log("üÜï ÏÑ∏ÏÖòÏù¥ ÏóÜÏùå, ÏÉà ÏÑ∏ÏÖò ÏÉùÏÑ±");
      await connectMcpServer();

      // Ïó∞Í≤∞ ÏÑ±Í≥µ ÌõÑ sessionId Î∞õÏïÑÏôÄÏÑú Ï†ÄÏû•
      async function fetchSessionIdWithRetry(api, config, maxRetries = 3, delay = 500) {
        for (let i = 0; i < maxRetries; i++) {
          const sessionId = await api.getMcpSessionId(config);
          if (sessionId) return sessionId;
          await new Promise(res => setTimeout(res, delay));
        }
        return null;
      }
      const sessionId = await fetchSessionIdWithRetry(api, selectedServer.config);
      console.log("‚ùå‚ùå‚ùå‚ùå ÏÑ∏ÏÖò ID:", sessionId)

      if (sessionId) {
        await api.saveServerSession(selectedServer.id, {
          sessionId,
          lastConnected: new Date(),
          transportType: selectedServer.config?.transportType || 'stdio',
          active: true
        });
        console.log(`[connectWithSessionReuse] Ïó∞Í≤∞ ÏÑ±Í≥µ ÌõÑ ÏÑ∏ÏÖò Ï†ÄÏû•: ${sessionId}`);
      } else {
        console.warn('[connectWithSessionReuse] Ïó∞Í≤∞ ÏÑ±Í≥µ ÌõÑ ÏÑ∏ÏÖòIDÎ•º Î∞õÏïÑÏò§ÏßÄ Î™ªÌï® (Ïû¨ÏãúÎèÑ ÌõÑÏóêÎèÑ Ïã§Ìå®)');
      }
    }
  } catch (error) {
    console.error("Error in session management:", error);
    await connectMcpServer(); // ÏóêÎü¨ ÏãúÏóêÎèÑ Ïó∞Í≤∞ ÏãúÎèÑ
  }
}, [selectedServer, connectMcpServer, connectionParams]);



// App.tsxÏùò startServer ÏàòÏ†ï
const startServer = useCallback(async (serverId: string): Promise<void> => {
  try {
    const api = ensureApi();
    if (!api) throw new Error('Electron API not available');
    
    const serverToStart = servers.find(server => server.id === serverId);
    if (serverToStart) {
      setSelectedServer(serverToStart);
      // Ïù¥ÎØ∏ running ÏÉÅÌÉúÎ©¥ Ïã§ÌñâÌïòÏßÄ ÏïäÏùå
      if (serverToStart.status === 'running') {
        setNotification({ message: 'ÏÑúÎ≤ÑÍ∞Ä Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.', type: 'info' });
        return;
      }
    }
    
    console.log('üöÄ ÏÑúÎ≤Ñ ÏãúÏûë ÏöîÏ≤≠:', serverId);
    const result = await api.startServer(serverId);
    
    if (result.success) {
      setNotification({ message: 'ÏÑúÎ≤ÑÍ∞Ä ÏãúÏûëÎêòÏóàÏäµÎãàÎã§.', type: 'success' });
      // ÏÑúÎ≤Ñ ÏÉÅÌÉú Í∞±Ïã†ÏùÑ Í∏∞Îã§Î¶º (ÏÑ∏ÏÖò ÏÉùÏÑ± ÌôïÏù∏ÏùÑ ÏúÑÌï¥)
      await new Promise(resolve => setTimeout(resolve, 1500));
      await refreshServerStatus();
      // ÏÑ∏ÏÖò Ï†ÄÏû•ÏùÄ Ïó∞Í≤∞ ÏÑ±Í≥µ ÌõÑ useEffectÏóêÏÑúÎßå Ï≤òÎ¶¨
    } else {
      setNotification({ message: `ÏÑúÎ≤Ñ ÏãúÏûë Ïã§Ìå®: ${result.message}`, type: 'error' });
    }
  } catch (error) {
    console.error('Error starting server:', error);
    setNotification({ message: 'ÏÑúÎ≤Ñ ÏãúÏûë Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', type: 'error' });
  }
}, [servers, refreshServerStatus, setSelectedServer]);


  // src/renderer/features/server/pages/job-page.tsx

  const stopServer = useCallback(async (serverId: string): Promise<void> => {
    try {
      const api = ensureApi();
      if (!api) throw new Error('Electron API not available');
      
      // ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏÑúÎ≤ÑÏù∏ÏßÄ ÌôïÏù∏
      const isSelectedServer = selectedServer && selectedServer.id === serverId;
      
      const result = await api.stopServer(serverId);
      
      if (result.success) {
        setNotification({ message: 'ÏÑúÎ≤ÑÍ∞Ä Ï§ëÏßÄÎêòÏóàÏäµÎãàÎã§.', type: 'success' });
        
        // userServer.json ÏÑ∏ÏÖò Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
        try {
          // ÏÑúÎ≤Ñ ÏÑ∏ÏÖò Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò¥
          const savedSession = await api.getServerSession(serverId);
          if (savedSession && savedSession.sessionId) {
            // ÏÑ∏ÏÖòÏùÑ ÎπÑÌôúÏÑ± ÏÉÅÌÉúÎ°ú ÌëúÏãú
            await api.saveServerSession(serverId, {
              sessionId: '',
              lastConnected: new Date(),
              transportType: savedSession.transportType || 'stdio',
              commandType: 'unknown',
              active: false  // ÎπÑÌôúÏÑ± ÏÉÅÌÉúÎ°ú ÌëúÏãú
            });
            console.log(`‚úÖ ÏÑúÎ≤Ñ Ï§ëÏßÄÎê®: userServer.json ÏÑ∏ÏÖò Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏Îê®`);
          }
        } catch (sessionError) {
          console.error('ÏÑ∏ÏÖò Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•ò:', sessionError);
        }
        
        // Ï§ëÏßÄÌïú ÏÑúÎ≤ÑÍ∞Ä ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÏÑúÎ≤ÑÏù∏ Í≤ΩÏö∞ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†ú Î∞è ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        if (isSelectedServer && mcpClient) {
          console.log('üîå Ï§ëÏßÄÎêú ÏÑúÎ≤ÑÏùò ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†ú Ï§ë...');
          await disconnectMcpServer();
          
          // ÎèÑÍµ¨ Î∞è Î¶¨ÏÜåÏä§ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
          clearTools();
          clearResources();
          clearResourceTemplates();
          clearPrompts();
        }
        
        await refreshServerStatus();
      } else {
        setNotification({ message: `ÏÑúÎ≤Ñ Ï§ëÏßÄ Ïã§Ìå®: ${result.message}`, type: 'error' });
      }
    } catch (error) {
      console.error('Error stopping server:', error);
      setNotification({ message: 'ÏÑúÎ≤Ñ Ï§ëÏßÄ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', type: 'error' });
    }
  }, [refreshServerStatus, selectedServer, mcpClient, disconnectMcpServer, clearTools, clearResources, clearResourceTemplates, clearPrompts]);


  const addNewServer = useCallback(async (serverConfig: {
    name: string;
    command: string;
    args: string[];
    transportType: 'stdio' | 'sse' | 'streamable-http';
    env?: Record<string, string>;
  }): Promise<void> => {
    try {
      const api = ensureApi();
      if (!api) throw new Error('Electron API not available');
      
      const result = await api.addServerConfig(serverConfig);
      
      if (result.success) {
        setNotification({ message: 'ÏÉà ÏÑúÎ≤ÑÍ∞Ä Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.', type: 'success' });
        await refreshServerStatus();
      } else {
        setNotification({ message: `ÏÑúÎ≤Ñ Ï∂îÍ∞Ä Ïã§Ìå®: ${result.message}`, type: 'error' });
      }
    } catch (error) {
      console.error('Error adding new server:', error);
      setNotification({ message: 'ÏÑúÎ≤Ñ Ï∂îÍ∞Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', type: 'error' });
    }
  }, [refreshServerStatus]);

  // Auto-connect to previously saved serverURL after OAuth callback
  const onOAuthConnect = useCallback(
    (serverUrl: string) => {
      setSseUrl(serverUrl);
      setTransportType("sse");
      void connectMcpServer();
    },
    [connectMcpServer, setSseUrl, setTransportType],
  );

  // üî• Initialize servers in multi-server mode
// Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú ÏÑúÎ≤Ñ ÏÉÅÌÉú Í∞±Ïã†
  useEffect(() => {
    if (multiServerMode) {
      console.log("Initializing multi-server mode...");
      refreshServerStatus();
      
      // 10Ï¥àÎßàÎã§ ÏÑúÎ≤Ñ ÏÉÅÌÉú Í∞±Ïã†
      const interval = setInterval(refreshServerStatus, 10000);
      return () => clearInterval(interval);
    }
  }, [multiServerMode, refreshServerStatus]);

  // üî• Auto-connect when server is selected and running
  useEffect(() => {
    console.log("=== Auto-connect with Session Reuse ===");
    
    if (multiServerMode && selectedServer && selectedServer.status === 'running' && !mcpClient) {
      console.log('Auto-connecting with session reuse...');
      
      const timer = setTimeout(() => {
        connectWithSessionReuse(); // ‚úÖ ÏÑ∏ÏÖò Ïû¨ÏÇ¨Ïö© Î°úÏßÅ ÏÇ¨Ïö©
      }, 1000);
      
      return () => clearTimeout(timer);
    }
  }, [multiServerMode, selectedServer, mcpClient, connectWithSessionReuse]);

  // Fetch default environment configuration
  useEffect(() => {

    // fetch(`${getMCPProxyAddress(config)}/servers/full-config`)
    //   .then((response) => {
    //     console.log(response.json())
    //     console.log("‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ")
      
    //   })
   
    
    fetch(`${getMCPProxyAddress(config)}/config`)
      .then((response) => response.json())
      .then((data) => {
        console.log('‚úÖ‚ùå‚ùå‚úÖ', data);
        setEnv(data.defaultEnvironment);
        if (data.defaultCommand) {
          setCommand(data.defaultCommand);
        }
        if (data.defaultArgs) {
          setArgs(data.defaultArgs);
        }
      })
      .catch((error) =>
        console.error("Error fetching default environment:", error),
      );
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Keep roots reference updated
  useEffect(() => {
    rootsRef.current = roots;
  }, [roots]);

  // Set default hash if none exists
  useEffect(() => {
    if (!window.location.hash) {
      window.location.hash = "resources";
    }
  }, []);

  // Handler functions
  const handleApproveSampling = useCallback((id: number, result: CreateMessageResult) => {
    setPendingSampleRequests((prev) => {
      const request = prev.find((r) => r.id === id);
      request?.resolve(result);
      return prev.filter((r) => r.id !== id);
    });
  }, []);

  const handleRejectSampling = useCallback((id: number) => {
    setPendingSampleRequests((prev) => {
      const request = prev.find((r) => r.id === id);
      request?.reject(new Error("Sampling request rejected"));
      return prev.filter((r) => r.id !== id);
    });
  }, []);

  const handleRootsChange = useCallback(async () => {
    await sendNotification({ method: "notifications/roots/list_changed" });
  }, [sendNotification]);

  const handleSetLogLevel = useCallback(async (level: LoggingLevel) => {
    await setLogLevel(level);
  }, [setLogLevel]);

  const clearStdErrNotifications = useCallback(() => {
    setStdErrNotifications([]);
  }, []);

  // API handler functions
  const handleListResources = useCallback(() => {
    console.log("Calling listResources...");
    listResources().catch(console.error);
  }, [listResources]);

  const handleListResourceTemplates = useCallback(() => {
    console.log("Calling listResourceTemplates...");
    listResourceTemplates().catch(console.error);
  }, [listResourceTemplates]);

  const handleReadResource = useCallback((uri: string) => {
    readResource(uri).catch(console.error);
  }, [readResource]);

  const handleSubscribeToResource = useCallback((uri: string) => {
    subscribeToResource(uri).catch(console.error);
  }, [subscribeToResource]);

  const handleUnsubscribeFromResource = useCallback((uri: string) => {
    unsubscribeFromResource(uri).catch(console.error);
  }, [unsubscribeFromResource]);

  const handleListPrompts = useCallback(() => {
    console.log("Calling listPrompts...");
    listPrompts().catch(console.error);
  }, [listPrompts]);

  const handleGetPrompt = useCallback((name: string, args: Record<string, string> = {}) => {
    getPrompt(name, args).catch(console.error);
  }, [getPrompt]);

  const handleListTools = useCallback(() => {
    console.log("Calling listTools...");
    listTools().catch(console.error);
  }, [listTools]);

  const handleCallTool = useCallback((name: string, params: Record<string, unknown>) => {
    callTool(name, params, progressTokenRef.current++).catch(console.error);
  }, [callTool]);

  const handlePing = useCallback(() => {
    ping().catch(console.error);
  }, [ping]);

  // ÏÑúÎ≤Ñ Ïã§Ìñâ + Ïó∞Í≤∞ + ÏÑ∏ÏÖò Ï†ÄÏû•ÏùÑ Ìïú Î≤àÏóê Ï≤òÎ¶¨ÌïòÎäî Ìï®Ïàò
  const handleStartAndConnect = useCallback(async (serverId: string) => {
    try {
      const api = ensureApi();
      if (!api) throw new Error('Electron API not available');
      console.log('1Ô∏è‚É£ [START] ÏÑúÎ≤Ñ Ïã§Ìñâ ÏöîÏ≤≠ ÏãúÏûë:', serverId);
      const serverToStart = servers.find(server => server.id === serverId);
      if (!serverToStart) {
        setNotification({ message: 'ÏÑúÎ≤ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.', type: 'error' });
        console.log('‚ùå [ERROR] ÏÑúÎ≤ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:', serverId);
        return;
      }
      // 1. ÏÑúÎ≤ÑÍ∞Ä Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù¥Î©¥ Ìå®Ïä§
      if (serverToStart.status === 'running') {
        setSelectedServer(serverToStart); // ÏÑ†ÌÉùÎßå ÌôïÏã§Ìûà!
        setNotification({ message: 'ÏÑúÎ≤ÑÍ∞Ä Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§.', type: 'info' });
        console.log('2Ô∏è‚É£ [SKIP] Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù∏ ÏÑúÎ≤Ñ:', serverToStart);
      } else {
        // 2. ÏÑúÎ≤Ñ Ïã§Ìñâ
        setNotification({ message: 'ÏÑúÎ≤ÑÎ•º ÏãúÏûëÌï©ÎãàÎã§...', type: 'info' });
        console.log('2Ô∏è‚É£ [RUN] ÏÑúÎ≤Ñ Ïã§Ìñâ ÏãúÎèÑ:', serverId);
        const result = await api.startServer(serverId);
        console.log('3Ô∏è‚É£ [RESULT] ÏÑúÎ≤Ñ Ïã§Ìñâ Í≤∞Í≥º:', result);
        if (!result.success) {
          setNotification({ message: `ÏÑúÎ≤Ñ ÏãúÏûë Ïã§Ìå®: ${result.message}`, type: 'error' });
          console.log('‚ùå [ERROR] ÏÑúÎ≤Ñ ÏãúÏûë Ïã§Ìå®:', result.message);
          return;
        }
        // ÏÉÅÌÉú Í∞±Ïã† ÎåÄÍ∏∞
        console.log('4Ô∏è‚É£ [WAIT] ÏÉÅÌÉú Í∞±Ïã† ÎåÄÍ∏∞...');
        await new Promise(resolve => setTimeout(resolve, 1500));
        await refreshServerStatus();
        console.log('5Ô∏è‚É£ [REFRESH] ÏÑúÎ≤Ñ ÏÉÅÌÉú Í∞±Ïã† ÏôÑÎ£å');
        // ÏÑúÎ≤Ñ ÏÉÅÌÉú Í∞±Ïã† ÌõÑ, selectedServerÎ•º Îã§Ïãú set
        const updatedServers = await api.getFullConfigs();
        console.log('6Ô∏è‚É£ [UPDATED_SERVERS] ÏµúÏã† ÏÑúÎ≤Ñ Î™©Î°ù:', updatedServers);
        const updated = updatedServers.find((s: ServerInfo) => s.id === serverId);
        console.log('7Ô∏è‚É£ [UPDATED] Í∞±Ïã†Îêú ÏÑúÎ≤Ñ Ï†ïÎ≥¥:', updated);
        if (updated) {
          setSelectedServer(updated);

        } else {
          console.log('7Ô∏è‚É£ [UPDATED] Í∞±Ïã†Îêú ÏÑúÎ≤Ñ Ï†ïÎ≥¥ ÏóÜÏùå');
        }
      }
      // Ïó∞Í≤∞(connect)ÏùÄ useEffectÏóêÏÑú ÏûêÎèôÏúºÎ°ú!
      console.log('9Ô∏è‚É£ [END] handleStartAndConnect Ï¢ÖÎ£å');
    } catch (error) {
      console.error('‚ùå [ERROR] handleStartAndConnect:', error);
      setNotification({ message: 'ÏÑúÎ≤Ñ Ïã§Ìñâ/Ïó∞Í≤∞ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.', type: 'error' });
    }
  }, [servers, refreshServerStatus, setSelectedServer]);
  // flex-1 overflow-y-auto h-full py-10 md:py-20 px-5 md:px-10
  // Render the UI
  return (
<div className="flex bg-background" style={{ height: "calc(100vh - 5rem)" }}>
      {multiServerMode ? (
        <div className="flex ">
          <ServerManagementSidebar
            servers={servers as any[]}
            selectedServer={selectedServer as any}
            selectedServers={selectedServers}
            setSelectedServer={setSelectedServer}
            setSelectedServers={setSelectedServers}
            startServer={handleStartAndConnect}
            stopServer={stopServer}
            refreshStatus={refreshServerStatus}
            addNewServer={addNewServer}
          />
          {/* Mode Toggle Button */}
          <div className="w-12 border-r border-border flex flex-col">
            <button
              onClick={() => setMultiServerMode(false)}
              className="p-3 text-sm text-gray-600 hover:bg-gray-100 border-b"
              title="Switch to Single Server Mode"
            >
              Single
            </button>
          </div>
        </div>
      ) : (
        <div className="flex">
          <Sidebar
            connectionStatus={connectionStatus}
            transportType={transportType}
            setTransportType={setTransportType}
            command={command}
            setCommand={setCommand}
            args={args}
            setArgs={setArgs}
            sseUrl={sseUrl}
            setSseUrl={setSseUrl}
            env={env}
            setEnv={setEnv}
            config={config}
            setConfig={setConfig}
            bearerToken={bearerToken}
            setBearerToken={setBearerToken}
            headerName={headerName}
            setHeaderName={setHeaderName}
            onConnect={connectMcpServer}
            onDisconnect={disconnectMcpServer}
            stdErrNotifications={stdErrNotifications}
            logLevel={serverCapabilities?.logging?.level || "debug"}
            sendLogLevelRequest={handleSetLogLevel}
            loggingSupported={!!serverCapabilities?.logging || false}
            clearStdErrNotifications={clearStdErrNotifications}
          />
          {/* Mode Toggle Button */}
          <div className="w-12 border-r border-border flex flex-col">
            <button
              onClick={() => setMultiServerMode(true)}
              className="p-3 text-sm text-gray-600 hover:bg-gray-100 border-b"
              title="Switch to Multi Server Mode"
            >
              Multi
            </button>
          </div>
        </div>
      )}

      <div className="flex-1 flex flex-col">
        {/* Notification Bar */}

        <div className="flex-1 overflow-auto">
          {mcpClient ? (
            <TabsContainer
              serverCapabilities={serverCapabilities}
              pendingRequestsCount={pendingSampleRequests.length}
              value={tab}
              onValueChange={setTab}
            >
              {tab === "resources" && (
                <ResourcesTab
                  resources={resources}
                  resourceTemplates={resourceTemplates}
                  listResources={handleListResources}
                  clearResources={clearResources}
                  listResourceTemplates={handleListResourceTemplates}
                  clearResourceTemplates={clearResourceTemplates}
                  readResource={handleReadResource}
                  selectedResource={selectedResource}
                  setSelectedResource={setSelectedResource}
                  resourceSubscriptionsSupported={serverCapabilities?.resources?.subscribe || false}
                  resourceSubscriptions={resourceSubscriptions}
                  subscribeToResource={handleSubscribeToResource}
                  unsubscribeFromResource={handleUnsubscribeFromResource}
                  handleCompletion={handleCompletion}
                  completionsSupported={completionsSupported}
                  resourceContent={resourceContent}
                  nextCursor={undefined}
                  nextTemplateCursor={undefined}
                  error={errors.resources}
                />
              )}
              {tab === "prompts" && (
                <PromptsTab
                  prompts={prompts}
                  listPrompts={handleListPrompts}
                  clearPrompts={clearPrompts}
                  getPrompt={handleGetPrompt}
                  selectedPrompt={selectedPrompt}
                  setSelectedPrompt={setSelectedPrompt}
                  handleCompletion={handleCompletion}
                  completionsSupported={completionsSupported}
                  promptContent={promptContent}
                  nextCursor={undefined}
                  error={errors.prompts}
                  serverCapabilities={serverCapabilities}
                />
              )}
              {tab === "tools" && (
                <ToolsTab
                  tools={tools}
                  listTools={handleListTools}
                  clearTools={clearTools}
                  callTool={handleCallTool}
                  selectedTool={selectedTool}
                  setSelectedTool={setSelectedTool}
                  toolResult={toolResult}
                  nextCursor={undefined}
                  error={errors.tools}
                />
              )}
              <ConsoleTab />
              <PingTab onPingClick={handlePing} />
              <SamplingTab
                pendingRequests={pendingSampleRequests}
                onApprove={handleApproveSampling}
                onReject={handleRejectSampling}
              />
              <RootsTab
                roots={roots}
                setRoots={setRoots}
                onRootsChange={handleRootsChange}
              />
            </TabsContainer>
          ) : (
            <div className="flex items-center justify-center h-full">
              <div className="text-center">
                <p className="text-lg text-gray-500 mb-4">
                  {multiServerMode ? 
                    (selectedServer ? 
                      `Select and start a server to begin inspection` :
                      `Select a server from the sidebar to begin`
                    ) : 
                    `Connect to an MCP server to start inspecting`
                  }
                </p>
              </div>
            </div>
          )}
        </div>
        <div
          className="relative border-t border-border"
          style={{
            height: `${historyPaneHeight}px`,
          }}
        >
          <div
            className="absolute w-full h-4 -top-2 cursor-row-resize flex items-center justify-center hover:bg-accent/50"
            onMouseDown={handleDragStart}
          >
            <div className="w-8 h-1 rounded-full bg-border" />
          </div>
          <div className="h-full overflow-auto">
            <HistoryAndNotifications
              requestHistory={requestHistory}
              serverNotifications={notifications}
            />
          </div>
        </div>
      </div>
    </div>
  );
};

export default JobPage;