// main/stores/integration/ai-mcp-coordinator.ts
import { createStore } from 'zustand/vanilla';
import { v4 as uuidv4 } from 'uuid';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  ListToolsResultSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { mcpRegistryStore } from '../mcp/mcpRegistryStore';
import { transportStore } from '../transport/transportStore';
import { clientStore } from '../client/clientStore';
import { chatStore } from '../chat/chatStore';
import { RegisteredTool } from '../mcp/mcpRegistry-type';

interface MCPBinding {
  id: string;
  sessionId: string;
  serverId: string;
  clientId: string;
  transportSessionId: string;
  status: 'active' | 'inactive' | 'error';
  error?: string;
  createdAt: string;
}

export interface MCPCoordinatorState {
  sessionBindings: Record<string, MCPBinding[]>;
  activeToolCalls: Record<
    string,
    {
      sessionId: string;
      toolName: string;
      startTime: string;
      status: 'running' | 'completed' | 'failed';
    }
  >;

  // Actions
  connectMCPToSession: (payload: {
    sessionId: string;
    serverId: string;
  }) => Promise<string>;
  disconnectMCPFromSession: (payload: {
    sessionId: string;
    bindingId: string;
  }) => Promise<void>;
  executeToolForSession: (payload: {
    sessionId: string;
    toolName: string;
    args: any;
  }) => Promise<any>;
  getSessionTools: (payload: {
    sessionId: string;
  }) => Promise<RegisteredTool[]>;
  cleanupSession: (payload: { sessionId: string }) => Promise<void>;
  // Getters
  getSessionBindings: (payload: { sessionId: string }) => MCPBinding[];
  isServerConnectedToSession: (payload: {
    sessionId: string;
    serverId: string;
  }) => boolean;
  pingMCPServer: (payload: {
    sessionId: string;
    serverId: string;
  }) => Promise<{ success: boolean; latency: number }>;
}

export const mcpCoordinatorStore = createStore<MCPCoordinatorState>(
  (set, get) => ({
    sessionBindings: {},
    activeToolCalls: {},

    connectMCPToSession: async (payload) => {
      const { sessionId, serverId } = payload;
      try {
        console.log(
          `üîó Connecting MCP server ${serverId} to session ${sessionId}`,
        );
    
        // Ïù¥ÎØ∏ Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        if (get().isServerConnectedToSession({ sessionId, serverId })) {
          console.log(`Already connected: ${serverId} to session ${sessionId}`);
          return '';
        }
    
        // 1. MCP RegistryÏóêÏÑú ÏÑúÎ≤Ñ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
        const server = mcpRegistryStore.getState().servers[serverId];
        if (!server) throw new Error(`Server ${serverId} not found`);
    
        // 2. Transport ÏÉùÏÑ±
        console.log('üöÄ Creating transport...');
        const transportSessionId = await transportStore
          .getState()
          .createTransport({
            serverId,
            config: {
              transportType: server.transportType,
              command: server.command,
              args: server.args,
              env: server.env,
              url: server.url,
            },
          });
    
        // 3. Client ÏÉùÏÑ±
        const clientId = clientStore.getState().createClient({
          sessionId,
          name: `${sessionId}-${serverId}`,
          capabilities: {
            sampling: {},
            roots: { listChanged: true },
            experimental: {},
          },
        });
    
        // 4. Transport Í∞ÄÏ†∏Ïò§Í∏∞
        const transport = transportStore.getState().getTransport({ sessionId: transportSessionId });
        if (!transport) throw new Error('Transport not found');
    
        // 5. Client Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Î∞è Ïó∞Í≤∞
        const client = new Client(
          {
            name: `${sessionId}-${serverId}`,
            version: '1.0.0',
          },
          {
            capabilities: {
              sampling: {},
              roots: { listChanged: true },
              experimental: {},
            },
          },
        );
    
        console.log('üîå Connecting client to transport...');
        await client.connect(transport);
        console.log('‚úÖ Client connected to transport');
    
        // üîë ÌïµÏã¨: setupNotificationHandlersÎ•º ÌÜµÌï¥ client Ïù∏Ïä§ÌÑ¥Ïä§ Ï†ÄÏû•
        clientStore.getState().setupNotificationHandlers({ clientId, client });
    
        // StoreÏóêÎäî ÏßÅÎ†¨Ìôî Í∞ÄÎä•Ìïú Îç∞Ïù¥ÌÑ∞Îßå Ï†ÄÏû•
        clientStore.getState().updateClientStatus({
          clientId,
          status: 'connected',
          error: undefined,
        });
    
        // serverCapabilities Ï†ÄÏû•
        clientStore.getState().updateClient({
          clientId,
          updates: {
            serverCapabilities: client.getServerCapabilities?.() || {},
          },
        });
    
        // 6. ‚ú® mcpRegistryStoreÏóê ÏÑúÎ≤Ñ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏ (clientId Ï∂îÍ∞Ä)
        mcpRegistryStore.getState().registerServer({
          ...server,
          clientId,
          status: 'connected',
        });
    
        // 7. Î∞îÏù∏Îî© Ï†ïÎ≥¥ Ï†ÄÏû•
        const bindingId = `Binding-${uuidv4()}`;
        const binding: MCPBinding = {
          id: bindingId,
          sessionId,
          serverId,
          clientId,
          transportSessionId,
          status: 'active',
          createdAt: new Date().toISOString(),
        };
    

        // Í∞Å storeÏùò set Ìò∏Ï∂ú Ï†ÑÏóê ÎîîÎ≤ÑÍπÖ Ï∂îÍ∞Ä
          set((state) => {
            console.log('üîç Setting state for store:', 'clientStore'); // store Ïù¥Î¶Ñ Î™ÖÏãú
            console.log('üì¶ State keys:', Object.keys(state));
            
            // ÏßÅÎ†¨Ìôî Î∂àÍ∞ÄÎä•Ìïú Í∞ùÏ≤¥ Ï∞æÍ∏∞
            Object.entries(state).forEach(([key, value]) => {
              if (value && typeof value === 'object') {
                if (value.constructor && value.constructor.name !== 'Object' && value.constructor.name !== 'Array') {
                  console.error(`‚ùå Non-serializable object found in ${key}:`, value.constructor.name);
                }
              }
            });
            
            return {
              sessionBindings: {
                ...state.sessionBindings,
                [sessionId]: [...(state.sessionBindings[sessionId] || []), binding],
              },
            };
          });
        // set((state) => ({
        //   sessionBindings: {
        //     ...state.sessionBindings,
        //     [sessionId]: [...(state.sessionBindings[sessionId] || []), binding],
        //   },
        // }));

        

        
        // 8. ‚ú® mcpRegistryStoreÎ•º ÌÜµÌï¥ capabilities Î∞úÍ≤¨
        console.log('üîß Discovering server capabilities...');
        const capabilities = await mcpRegistryStore
          .getState()
          .discoverServerCapabilities(serverId);
        
        console.log(
          `‚úÖ Discovered ${capabilities.tools.length} tools, ${capabilities.prompts.length} prompts`,
        );
    
        // 9. ChatStoreÏóê ÌôúÏÑ± ÎèÑÍµ¨ ÏóÖÎç∞Ïù¥Ìä∏
        const config = chatStore.getState().getConfig(sessionId);
        if (config && capabilities.tools.length > 0) {
          const newActiveTools = [
            ...new Set([
              ...(config.activeTools || []),
              ...capabilities.tools.map(t => t.name),
            ]),
          ];
          
          chatStore.getState().updateConfig({
            sessionId,
            config: {
              activeTools: newActiveTools,
            },
          });
          
          console.log(
            'üõ†Ô∏è [chatStore.configs] activeTools ÏóÖÎç∞Ïù¥Ìä∏ ÌõÑ:',
            chatStore.getState().configs[sessionId],
          );
        }
    
        console.log(`‚úÖ MCP connected: ${serverId} to session ${sessionId}`);
        return bindingId;
      } catch (error) {
        console.error(`‚ùå Failed to connect MCP:`, error);
    
        // ÏóêÎü¨ Î∞îÏù∏Îî© Ï†ÄÏû•
        const bindingId = `Binding-${uuidv4()}`;
        set((state) => ({
          sessionBindings: {
            ...state.sessionBindings,
            [sessionId]: [
              ...(state.sessionBindings[sessionId] || []),
              {
                id: bindingId,
                sessionId,
                serverId,
                clientId: '',
                transportSessionId: '',
                status: 'error',
                error: error instanceof Error ? error.message : 'Unknown error',
                createdAt: new Date().toISOString(),
              },
            ],
          },
        }));
    
        throw error;
      }
    },

    disconnectMCPFromSession: async (payload) => {
      const { sessionId, bindingId } = payload;
      const bindings = get().sessionBindings[sessionId] || [];
      const binding = bindings.find((b) => b.id === bindingId);
      if (!binding || binding.status !== 'active') return;

      try {
        // Client Ïó∞Í≤∞ Ìï¥Ï†ú
        await (clientStore.getState().disconnectClient as any)({
          clientId: binding.clientId,
        });
        await (clientStore.getState().deleteClient as any)({
          clientId: binding.clientId,
        });

        // Transport Ï¢ÖÎ£å
        await transportStore
          .getState()
          .closeTransport({ sessionId: binding.transportSessionId });

        // Î∞îÏù∏Îî© ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        set((state) => ({
          sessionBindings: {
            ...state.sessionBindings,
            [sessionId]: state.sessionBindings[sessionId].map((b) =>
              b.id === bindingId ? { ...b, status: 'inactive' as const } : b,
            ),
          },
        }));

        // üîÑ Î∞îÏù∏Îî© ÌÅ¥Î¶∞ÏóÖ: inactive, error Î∞îÏù∏Îî© Ï†úÍ±∞
        set((state) => ({
          sessionBindings: {
            ...state.sessionBindings,
            [sessionId]: (state.sessionBindings[sessionId] || []).filter(
              (b) => b.status === 'active',
            ),
          },
        }));

        // ChatStoreÏóêÏÑú ÎèÑÍµ¨ Ï†úÍ±∞
        const tools = mcpRegistryStore
          .getState()
          .getServerTools(binding.serverId);
        const config = chatStore.getState().getConfig(sessionId);
        if (config) {
          chatStore.getState().updateConfig({
            sessionId,
            config: {
              activeTools: (config.activeTools || []).filter(
                (t: string) => !tools.some((tool: any) => tool.name === t),
              ),
            },
          });
        }

        console.log(
          `‚úÖ MCP disconnected: ${binding.serverId} from session ${sessionId}`,
        );
      } catch (error) {
        console.error(`Failed to disconnect MCP:`, error);
        throw error;
      }
    },

    // ÎèÑÍµ¨ Ïã§Ìñâ - mcpRegistryStore ÌôúÏö©
    executeToolForSession: async (payload) => {
      const { sessionId, toolName, args } = payload;
      
      console.log(`üöÄ [mcp_coordinator.executeToolForSession] Ìò∏Ï∂úÎê®!`);
      console.log(`üìã sessionId: ${sessionId}`);
      console.log(`üîß toolName: ${toolName}`);
      console.log(`üì¶ args:`, args);
      
      // ÎèÑÍµ¨Í∞Ä Îì±Î°ùÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const tool = mcpRegistryStore.getState().getTool(toolName);
      if (!tool) {
        console.error(`‚ùå Tool not found in registry: ${toolName}`);
        throw new Error(`Tool ${toolName} not found in registry`);
      }
      
      console.log(`‚úÖ Tool found:`, tool);
      console.log(`üîó Tool server: ${tool.serverId} (${tool.serverName})`);
      
      // mcpRegistryStoreÏùò executeTool ÏÇ¨Ïö©
      console.log(`üì§ Calling mcpRegistryStore.executeTool...`);
      const result = await mcpRegistryStore.getState().executeTool(toolName, args);
      console.log(`üì® Result from mcpRegistryStore.executeTool:`, result);
      
      return result;
    },

    getSessionTools: async (payload) => {
      const { sessionId } = payload;
      const bindings = get().sessionBindings[sessionId] || [];
      const tools: RegisteredTool[] = [];
    
      for (const binding of bindings.filter(b => b.status === 'active')) {
        const serverTools = mcpRegistryStore
          .getState()
          .getServerTools(binding.serverId);
        tools.push(...serverTools);
      }
    
      return tools;
    },
    
    cleanupSession: async (payload) => {
      const { sessionId } = payload;
      const bindings = get().sessionBindings[sessionId] || [];

      // Î™®Îì† ÌôúÏÑ± Ïó∞Í≤∞ Ìï¥Ï†ú
      await Promise.all(
        bindings
          .filter((b) => b.status === 'active')
          .map((b) =>
            get().disconnectMCPFromSession({ sessionId, bindingId: b.id }),
          ),
      );

      // Î∞îÏù∏Îî© Ï†ïÎ≥¥ ÏÇ≠Ï†ú
      set((state) => {
        const { [sessionId]: removed, ...sessionBindings } =
          state.sessionBindings;
        return { sessionBindings };
      });

      console.log(`üßπ Session cleaned up: ${sessionId}`);
    },

    getSessionBindings: (payload) => {
      const { sessionId } = payload;
      return get().sessionBindings[sessionId] || [];
    },

    isServerConnectedToSession: (payload) => {
      const { sessionId, serverId } = payload;
      const bindings = get().sessionBindings[sessionId] || [];
      return bindings.some(
        (b) => b.serverId === serverId && b.status === 'active',
      );
    },

    // Ping Î©îÏÑúÎìú Ï∂îÍ∞Ä
    pingMCPServer: async (payload: { sessionId: string; serverId: string }) => {
      const { sessionId, serverId } = payload;
      const bindings = get().sessionBindings[sessionId] || [];
      const binding = bindings.find(
        (b) => b.serverId === serverId && b.status === 'active',
      );

      if (!binding) throw new Error('Server not connected');

      try {
        const startTime = Date.now();

        // Í∞ÑÎã®Ìïú ÎèÑÍµ¨ Î™©Î°ù ÏöîÏ≤≠ÏúºÎ°ú ping ÌÖåÏä§Ìä∏
        await clientStore.getState().sendRequest({
          clientId: binding.clientId,
          request: { method: 'tools/list', params: {} },
          schema: ListToolsResultSchema, // ÏùëÎãµ Ïä§ÌÇ§Îßà ÏÇ¨Ïö©
          options: { timeout: 5000 }
        });

        const latency = Date.now() - startTime;

        console.log(`üèì Ping successful: ${serverId} - ${latency}ms`);
        return { success: true, latency };
      } catch (error) {
        console.error(`‚ùå Ping failed: ${serverId}`, error);

        // Ïó∞Í≤∞ Ïã§Ìå®Ïãú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        set((state) => ({
          sessionBindings: {
            ...state.sessionBindings,
            [sessionId]: state.sessionBindings[sessionId].map((b) =>
              b.id === binding.id
                ? { ...b, status: 'error' as const, error: 'Ping failed' }
                : b,
            ),
          },
        }));

        throw error;
      }
    },
  }),
);
