import express from 'express';
import { SseError } from '@modelcontextprotocol/sdk/client/sse.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';
import { parseMcpArgs, mcpConfig } from '../config/mcp';
import mcpProxy from '../services/mcp/proxy';
import {
  createTransport,
  getBackingServerTransport,
  setBackingServerTransport,
  webAppTransports,
  generateSessionId
} from '../services/mcp/transport';

const router = express.Router();

/**
 * @swagger
 * tags:
 *   name: MCP
 *   description: ModelContextProtocol ÌîÑÎ°ùÏãú API
 */

/**
 * @swagger
 * /mcp:
 *   get:
 *     summary: MCP Streamable HTTP ÏÑ∏ÏÖò Ïó∞Í≤∞ (GET)
 *     tags: [MCP]
 *     parameters:
 *       - in: header
 *         name: mcp-session-id
 *         required: true
 *         schema:
 *           type: string
 *         description: ÏÑ∏ÏÖò ID
 *     responses:
 *       200:
 *         description: ÏÑ±Í≥µÏ†ÅÏù∏ ÏùëÎãµ
 *       404:
 *         description: ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.get('/mcp', async (req, res) => {
  const sessionId = req.headers['mcp-session-id'] as string;
  console.log(`Received GET message for sessionId ${sessionId}`);
  try {
    const transport = webAppTransports.get(sessionId) as StreamableHTTPServerTransport;
    if (!transport) {
      res.status(404).end('Session not found');
      return;
    } else {
      await transport.handleRequest(req, res);
    }
  } catch (error) {
    console.error('Error in /mcp route:', error);
    res.status(500).json(error);
  }
});

/**
 * @swagger
 * /mcp:
 *   post:
 *     summary: MCP Streamable HTTP ÏÑ∏ÏÖò ÏÉùÏÑ± Î∞è Î©îÏãúÏßÄ Ï†ÑÏÜ° (POST)
 *     tags: [MCP]
 *     parameters:
 *       - in: header
 *         name: mcp-session-id
 *         required: false
 *         schema:
 *           type: string
 *         description: ÏÑ∏ÏÖò ID (ÏóÜÏúºÎ©¥ ÏÉà ÏÑ∏ÏÖò ÏÉùÏÑ±)
 *       - in: query
 *         name: transportType
 *         required: true
 *         schema:
 *           $ref: '#/components/schemas/TransportType'
 *       - in: query
 *         name: url
 *         schema:
 *           type: string
 *         description: Ïó∞Í≤∞Ìï† URL (sse ÎòêÎäî streamable-http Ï†ÑÏÜ° Î∞©Ïãù ÏÇ¨Ïö© Ïãú)
 *       - in: query
 *         name: command
 *         schema:
 *           type: string
 *         description: Ïã§ÌñâÌï† Î™ÖÎ†πÏñ¥ (stdio Ï†ÑÏÜ° Î∞©Ïãù ÏÇ¨Ïö© Ïãú)
 *       - in: query
 *         name: args
 *         schema:
 *           type: string
 *         description: Î™ÖÎ†πÏñ¥ Ïù∏Ïûê (stdio Ï†ÑÏÜ° Î∞©Ïãù ÏÇ¨Ïö© Ïãú)
 *     responses:
 *       200:
 *         description: ÏÑ±Í≥µÏ†ÅÏù∏ ÏùëÎãµ
 *       401:
 *         description: Ïù∏Ï¶ù Ïã§Ìå®
 *       404:
 *         description: ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.post('/mcp', async (req, res) => {
  const sessionId = req.headers['mcp-session-id'] as string | undefined;
  console.log(`Received POST /mcp for sessionId=${sessionId}`);

  if (!sessionId) {
    // Ïã†Í∑ú ÏÑ∏ÏÖò ÏÉùÏÑ±
    try {
      // (1) Í∏∞Ï°¥ Î∞±ÏóîÎìú Ïó∞Í≤∞ Ï¢ÖÎ£å Î∞è ÏÉà Ïó∞Í≤∞ ÏÉùÏÑ±
      try {
        const current = getBackingServerTransport();
        await current?.close();
        const next = await createTransport(req);
        setBackingServerTransport(next);
      } catch (err) {
        if (err instanceof SseError && err.code === 401) {
          return res.status(401).json(err);
        }
        throw err;
      }

      // (2) ÏõπÏö© Streamable HTTP ÏÑúÎ≤Ñ Ìä∏ÎûúÏä§Ìè¨Ìä∏
      const webApp = new StreamableHTTPServerTransport({
        sessionIdGenerator: generateSessionId,
        onsessioninitialized: id => {
          webAppTransports.set(id, webApp);
          console.log('Created web app transport', id);
        },
      });
      await webApp.start();

      // (3) MCP ÌîÑÎ°ùÏãú Ïó∞Í≤∞
      mcpProxy({
        transportToClient: webApp,
        transportToServer: getBackingServerTransport()!,
      });

      // (4) **req.body** ÎÇò Îã§Î•∏ body-parser ÏóÜÏù¥** SDK Í∞Ä ÏßÅÏ†ë Ïä§Ìä∏Î¶ºÏùÑ ÏùΩÎèÑÎ°ù
      await webApp.handleRequest(req, res);
    } catch (err) {
      console.error('Error in /mcp POST:', err);
      res.status(500).json(err);
    }
  } else {
    // Í∏∞Ï°¥ ÏÑ∏ÏÖòÏóê ÎåÄÌïú Î©îÏãúÏßÄ Ï†ÑÎã¨
    try {
      const transport = webAppTransports.get(sessionId) as StreamableHTTPServerTransport;
      if (!transport) {
        return res.status(404).end(`Transport not found for sessionId ${sessionId}`);
      }
      await transport.handleRequest(req, res);
    } catch (err) {
      console.error('Error in /mcp POST existing session:', err);
      res.status(500).json(err);
    }
  }
});


/**
 * @swagger
 * /stdio:
 *   get:
 *     summary: Stdio Ï†ÑÏÜ° Î∞©ÏãùÏúºÎ°ú Ïó∞Í≤∞
 *     tags: [MCP]
 *     parameters:
 *       - in: query
 *         name: transportType
 *         required: true
 *         schema:
 *           type: string
 *           enum: [stdio]
 *       - in: query
 *         name: command
 *         required: true
 *         schema:
 *           type: string
 *         description: Ïã§ÌñâÌï† Î™ÖÎ†πÏñ¥
 *       - in: query
 *         name: args
 *         schema:
 *           type: string
 *         description: Î™ÖÎ†πÏñ¥ Ïù∏Ïûê
 *     responses:
 *       200:
 *         description: ÏÑ±Í≥µÏ†ÅÏù∏ ÏùëÎãµ (Ïù¥Î≤§Ìä∏ Ïä§Ìä∏Î¶º)
 *       401:
 *         description: Ïù∏Ï¶ù Ïã§Ìå®
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
// 2. mcp.routes.ts ÏàòÏ†ï - stdio ÎùºÏö∞Ìä∏
router.get('/stdio', async (req, res) => {
  try {
    const { serverName, transportType, command, args } = req.query;
    
    // ÌïÑÏàò ÌååÎùºÎØ∏ÌÑ∞ Ï≤¥ÌÅ¨
    if (!serverName) {
      return res.status(400).json({ error: 'serverName parameter is required' });
    }
    if (!command) {
      return res.status(400).json({ error: 'command parameter is required' });
    }
    
    console.log(`üöÄ Creating connection for server: ${serverName}`);
    console.log(`   Command: ${command} ${args || ''}`);

    
    try {
      const currentTransport = getBackingServerTransport();
      await currentTransport?.close();
      const newTransport = await createTransport(req);
      setBackingServerTransport(newTransport);
    } catch (error) {
      if (error instanceof SseError && error.code === 401) {
        console.error('Received 401 Unauthorized from MCP server:', error.message);
        res.status(401).json(error);
        return;
      }
      throw error;
    }

    console.log(`‚úì Connected to server transport for ${serverName}`);

    // ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ transport ÏÉùÏÑ±
    const webAppTransport = new SSEServerTransport('/message', res);
    
    // ÏÑúÎ≤Ñ Ïù¥Î¶ÑÍ≥º ÏÑ∏ÏÖò ID Ï°∞Ìï©ÏúºÎ°ú ÌÇ§ ÏÉùÏÑ±
    const sessionKey = `${serverName}-${webAppTransport.sessionId}`;
    webAppTransports.set(sessionKey, webAppTransport);

    console.log(`‚úì Created web app transport: ${sessionKey}`);

    // ÏÑ∏ÏÖò ID Ìó§Îçî ÏÑ§Ï†ï
    res.setHeader('mcp-session-id', sessionKey);

    await webAppTransport.start();
    (getBackingServerTransport() as StdioClientTransport).stderr!.on(
      'data',
      (chunk) => {
        webAppTransport.send({
          jsonrpc: '2.0',
          method: 'notifications/stderr',
          params: {
            content: chunk.toString(),
          },
        });
      },
    );

    mcpProxy({
      transportToClient: webAppTransport,
      transportToServer: getBackingServerTransport()!,
    });

    console.log('Set up MCP proxy');
  } catch (error) {
    console.error('Error in /stdio route:', error);
    res.status(500).json(error);
  }
});

/**
 * @swagger
 * /sse:
 *   get:
 *     summary: SSE Ï†ÑÏÜ° Î∞©ÏãùÏúºÎ°ú Ïó∞Í≤∞ (deprecated)
 *     tags: [MCP]
 *     deprecated: true
 *     parameters:
 *       - in: query
 *         name: transportType
 *         required: true
 *         schema:
 *           type: string
 *           enum: [sse]
 *       - in: query
 *         name: url
 *         required: true
 *         schema:
 *           type: string
 *         description: SSE ÏÑúÎ≤Ñ URL
 *     responses:
 *       200:
 *         description: ÏÑ±Í≥µÏ†ÅÏù∏ ÏùëÎãµ (Ïù¥Î≤§Ìä∏ Ïä§Ìä∏Î¶º)
 *       401:
 *         description: Ïù∏Ï¶ù Ïã§Ìå®
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.get('/sse', async (req, res) => {
  try {
    console.log(
      'New SSE connection. NOTE: The sse transport is deprecated and has been replaced by streamable-http',
    );

    try {
      const currentTransport = getBackingServerTransport();
      await currentTransport?.close();
      const newTransport = await createTransport(req);
      setBackingServerTransport(newTransport);
    } catch (error) {
      if (error instanceof SseError && error.code === 401) {
        console.error('Received 401 Unauthorized from MCP server:', error.message);
        res.status(401).json(error);
        return;
      }
      throw error;
    }

    console.log('Connected MCP client to backing server transport');

    const webAppTransport = new SSEServerTransport('/message', res);
    webAppTransports.set(webAppTransport.sessionId, webAppTransport);
    console.log('Created web app transport');

    await webAppTransport.start();

    mcpProxy({
      transportToClient: webAppTransport,
      transportToServer: getBackingServerTransport()!,
    });

    console.log('Set up MCP proxy');
  } catch (error) {
    console.error('Error in /sse route:', error);
    res.status(500).json(error);
  }
});

/**
 * @swagger
 * /message:
 *   post:
 *     summary: SSE ÏÑ∏ÏÖòÏóê Î©îÏãúÏßÄ Ï†ÑÏÜ°
 *     tags: [MCP]
 *     parameters:
 *       - in: query
 *         name: sessionId
 *         required: true
 *         schema:
 *           type: string
 *         description: ÏÑ∏ÏÖò ID
 *     responses:
 *       200:
 *         description: ÏÑ±Í≥µÏ†ÅÏù∏ ÏùëÎãµ
 *       404:
 *         description: ÏÑ∏ÏÖòÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.post('/message', async (req, res) => {
  try {
    const sessionId = req.query.sessionId as string;
    console.log(`Received POST /message for sessionId=${sessionId}`);

    const transport = webAppTransports.get(sessionId) as SSEServerTransport;
    if (!transport) {
      return res.status(404).end('Session not found');
    }
    // Ïó≠Ïãú **body-parser ÏóÜÏù¥** SDK Í∞Ä ÏßÅÏ†ë Ïä§Ìä∏Î¶ºÏùÑ ÏùΩÏäµÎãàÎã§
    await transport.handlePostMessage(req, res);
  } catch (err) {
    console.error('Error in /message POST:', err);
    res.status(500).json(err);
  }
});
/**
 * @swagger
 * /health:
 *   get:
 *     summary: ÏÑúÎ≤Ñ ÏÉÅÌÉú ÌôïÏù∏
 *     tags: [MCP]
 *     responses:
 *       200:
 *         description: ÏÑúÎ≤ÑÍ∞Ä Ï†ïÏÉÅ ÏûëÎèô Ï§ë
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/SuccessResponse'
 */
router.get('/health', (req, res) => {
  res.json({
    status: 'ok',
  });
});

/**
 * @swagger
 * /config:
 *   get:
 *     summary: ÏÑúÎ≤Ñ ÏÑ§Ï†ï Ï†ïÎ≥¥ Ï°∞Ìöå
 *     tags: [MCP]
 *     responses:
 *       200:
 *         description: ÏÑ§Ï†ï Ï†ïÎ≥¥
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 defaultEnvironment:
 *                   type: object
 *                 defaultCommand:
 *                   type: string
 *                 defaultArgs:
 *                   type: string
 *       500:
 *         description: ÏÑúÎ≤Ñ Ïò§Î•ò
 */
router.get('/config', (req, res) => {
  try {
    const args = parseMcpArgs(process.argv.slice(2));
    res.json({
      defaultEnvironment: mcpConfig.defaultEnvironment,
      defaultCommand: args.env,
      defaultArgs: args.args,
    });
  } catch (error) {
    console.error('Error in /config route:', error);
    res.status(500).json(error);
  }
});




// 2. mcp.routes.ts ÏàòÏ†ï - stdio ÎùºÏö∞Ìä∏
router.get('/stdio', async (req, res) => {
  try {
    console.log('New connection');

    try {
      const currentTransport = getBackingServerTransport();
      await currentTransport?.close();
      const newTransport = await createTransport(req);
      setBackingServerTransport(newTransport);
    } catch (error) {
      if (error instanceof SseError && error.code === 401) {
        console.error('Received 401 Unauthorized from MCP server:', error.message);
        res.status(401).json(error);
        return;
      }
      throw error;
    }

    console.log('Connected MCP client to backing server transport');

    const webAppTransport = new SSEServerTransport('/message', res);
    webAppTransports.set(webAppTransport.sessionId, webAppTransport);

    console.log('Created web app transport');

    await webAppTransport.start();
    (getBackingServerTransport() as StdioClientTransport).stderr!.on(
      'data',
      (chunk) => {
        webAppTransport.send({
          jsonrpc: '2.0',
          method: 'notifications/stderr',
          params: {
            content: chunk.toString(),
          },
        });
      },
    );

    mcpProxy({
      transportToClient: webAppTransport,
      transportToServer: getBackingServerTransport()!,
    });

    console.log('Set up MCP proxy');
  } catch (error) {
    console.error('Error in /stdio route:', error);
    res.status(500).json(error);
  }
});

// 3. ÎèôÏãú Ïã§ÌñâÏùÑ ÏúÑÌïú ÏÉàÎ°úÏö¥ ÎùºÏö∞Ìä∏ Ï∂îÍ∞Ä
router.post('/mcp/batch-start', async (req, res) => {
  try {
    const { servers } = req.body; // [{serverName, command, args}, ...]
    
    if (!Array.isArray(servers) || servers.length === 0) {
      return res.status(400).json({ error: 'servers array is required' });
    }
    
    console.log(`üöÄ Starting ${servers.length} servers concurrently...`);
    
    const results = await Promise.allSettled(
      servers.map(async (server) => {
        const { serverName, command, args } = server;
        
        if (!serverName || !command) {
          throw new Error(`serverName and command are required for ${JSON.stringify(server)}`);
        }
        
        // Í∞Å ÏÑúÎ≤ÑÏóê ÎåÄÌï¥ stdio ÏóîÎìúÌè¨Ïù∏Ìä∏ Ìò∏Ï∂ú
        const response = await fetch(`http://localhost:${req.app.get('port') || 4303}/stdio?serverName=${encodeURIComponent(serverName)}&transportType=stdio&command=${encodeURIComponent(command)}&args=${encodeURIComponent(args || '')}`, {
          method: 'GET'
        });
        
        if (!response.ok) {
          throw new Error(`Failed to start ${serverName}: ${response.statusText}`);
        }
        
        return {
          serverName,
          status: 'started',
          sessionId: response.headers.get('mcp-session-id')
        };
      })
    );
    
    // Í≤∞Í≥º Ï†ïÎ¶¨
    const summary = {
      total: servers.length,
      succeeded: 0,
      failed: 0,
      results: results.map((result, index) => {
        if (result.status === 'fulfilled') {
          summary.succeeded++;
          return result.value;
        } else {
          summary.failed++;
          return {
            serverName: servers[index].serverName,
            status: 'failed',
            error: result.reason.message
          };
        }
      })
    };
    
    console.log(`‚úÖ Batch start complete: ${summary.succeeded}/${summary.total} succeeded`);
    res.json(summary);
    
  } catch (error) {
    console.error('‚ùå Error in /mcp/batch-start:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Í∞úÎ≥Ñ ÏÑúÎ≤Ñ Ï¢ÖÎ£åÎ•º ÏúÑÌïú ÏÉàÎ°úÏö¥ ÎùºÏö∞Ìä∏
router.post('/mcp/server/:serverId/stop', async (req, res) => {
  try {
    const { serverId } = req.params;
    
    if (!serverId) {
      return res.status(400).json({ error: 'serverId parameter is required' });
    }
    
    console.log(`üõë Stopping server ${serverId}...`);
    
    // Ìï¥Îãπ ÏÑúÎ≤ÑÏùò Î™®Îì† ÏÑ∏ÏÖò Ï¢ÖÎ£å
    const sessions = Array.from(webAppTransports.keys())
      .filter(key => key.startsWith(`${serverId}-`));
    
    console.log(`   Closing ${sessions.length} sessions for ${serverId}`);
    
    // Î™®Îì† ÏÑ∏ÏÖò Ï¢ÖÎ£å
    await Promise.all(sessions.map(async (sessionKey) => {
      const transport = webAppTransports.get(sessionKey);
      if (transport) {
        await transport.close();
        webAppTransports.delete(sessionKey);
      }
    }));
    
    // ÏÑúÎ≤Ñ transport Ï¢ÖÎ£å
    try {
      const currentTransport = getBackingServerTransport();
      await currentTransport?.close();
      const newTransport = await createTransport(req);
      setBackingServerTransport(newTransport);
    } catch (error) {
      if (error instanceof SseError && error.code === 401) {
        console.error('Received 401 Unauthorized from MCP server:', error.message);
        res.status(401).json(error);
        return;
      }
      throw error;
    }
    
    const result = {
      serverName: serverId,
      status: 'stopped',
      sessionsRemoved: sessions.length
    };
    
    console.log(`‚úÖ Server ${serverId} stopped successfully`);
    res.json(result);
    
  } catch (error) {
    console.error(`‚ùå Error stopping server ${req.params.serverId}:`, error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// 4. ÎèôÏãú Ï¢ÖÎ£åÎ•º ÏúÑÌïú ÏÉàÎ°úÏö¥ ÎùºÏö∞Ìä∏ Ï∂îÍ∞Ä
router.post('/mcp/batch-stop', async (req, res) => {
  try {
    const { serverNames } = req.body; // ['server1', 'server2', ...]
    
    if (!Array.isArray(serverNames) || serverNames.length === 0) {
      return res.status(400).json({ error: 'serverNames array is required' });
    }
    
    console.log(`üõë Stopping ${serverNames.length} servers...`);
    
    const results = await Promise.allSettled(
      serverNames.map(async (serverName) => {
        // Ìï¥Îãπ ÏÑúÎ≤ÑÏùò Î™®Îì† ÏÑ∏ÏÖò Ï¢ÖÎ£å
        const sessions = Array.from(webAppTransports.keys())
          .filter(key => key.startsWith(`${serverName}-`));
        
        console.log(`   Closing ${sessions.length} sessions for ${serverName}`);
        
        // Î™®Îì† ÏÑ∏ÏÖò Ï¢ÖÎ£å
        await Promise.all(sessions.map(async (sessionKey) => {
          const transport = webAppTransports.get(sessionKey);
          if (transport) {
            await transport.close();
            webAppTransports.delete(sessionKey);
          }
        }));
        
        try {
          const currentTransport = getBackingServerTransport();
          await currentTransport?.close();
          const newTransport = await createTransport(req);
          setBackingServerTransport(newTransport);
        } catch (error) {
          if (error instanceof SseError && error.code === 401) {
            console.error('Received 401 Unauthorized from MCP server:', error.message);
            res.status(401).json(error);
            return;
          }
          throw error;
        }

        
        return {
          serverName,
          status: 'stopped',
          sessionsRemoved: sessions.length
        };
      })
    );
    
    // Í≤∞Í≥º Ï†ïÎ¶¨
    const summary = {
      total: serverNames.length,
      succeeded: 0,
      failed: 0,
      results: results.map((result, index) => {
        if (result.status === 'fulfilled') {
          summary.succeeded++;
          return result.value;
        } else {
          summary.failed++;
          return {
            serverName: serverNames[index],
            status: 'failed',
            error: result.reason.message
          };
        }
      })
    };
    
    console.log(`‚úÖ Batch stop complete: ${summary.succeeded}/${summary.total} succeeded`);
    res.json(summary);
    
  } catch (error) {
    console.error('‚ùå Error in /mcp/batch-stop:', error);
    res.status(500).json({
      error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});


type ActiveServerInfo = {
  serverName: string;
  sessions: { sessionId: string; active: boolean }[];
  totalSessions: number;
};

// 5. ÌôúÏÑ± ÏÑúÎ≤Ñ Î™©Î°ù Ï°∞Ìöå ÎùºÏö∞Ìä∏
router.get('/mcp/active-servers', (req, res) => {
  const activeServers: ActiveServerInfo[] = [];  
  // ÏÑúÎ≤ÑÎ≥ÑÎ°ú ÌôúÏÑ± ÏÑ∏ÏÖò Ï†ïÎ≥¥ ÏàòÏßë
  for (const [sessionKey, transport] of webAppTransports.entries()) {
    const serverName = sessionKey.split('-')[0];
  let serverInfo = activeServers.find(s => s.serverName === serverName);
    
    if (!serverInfo) {
      serverInfo = {
        serverName,
        sessions: [],
        totalSessions: 0
      };
      activeServers.push(serverInfo);
    }
    
    serverInfo.sessions.push({
      sessionId: sessionKey,
      active: transport !== undefined
    });
    serverInfo.totalSessions++;
  }
  
  res.json({
    total: activeServers.length,
    servers: activeServers
  });
});






export default router;
